# NEP-17 Token Template
# This template provides a complete NEP-17 fungible token implementation

[template]
name = "nep17-token"
description = "NEP-17 compliant fungible token with full functionality"
version = "1.0.0"
author = "NeoRust Team"

[files]
"src/main.rs" = '''
//! NEP-17 Token Management dApp
//! 
//! This application provides:
//! - Token deployment
//! - Transfer operations
//! - Balance checking
//! - Token administration

use neo3::sdk::{Neo, Network};
use neo3::neo_types::{ScriptHash, ContractParameter};
use neo3::neo_builder::{TransactionBuilder, ScriptBuilder};
use std::error::Error;
use std::str::FromStr;

mod token;
use token::Nep17Token;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    println!("ðŸª™ NEP-17 Token Manager");
    
    // Connect to network
    let neo = Neo::testnet().await?;
    println!("âœ… Connected to TestNet");
    
    // Example token contract hash (replace with your token)
    let token_hash = ScriptHash::from_str("0x...")
        .unwrap_or_else(|_| ScriptHash::default());
    
    // Create token instance
    let token = Nep17Token::new(token_hash, neo);
    
    // Get token info
    let symbol = token.symbol().await?;
    let decimals = token.decimals().await?;
    let total_supply = token.total_supply().await?;
    
    println!("ðŸ“Š Token Information:");
    println!("   Symbol: {}", symbol);
    println!("   Decimals: {}", decimals);
    println!("   Total Supply: {}", total_supply);
    
    Ok(())
}
'''

"src/token.rs" = '''
//! NEP-17 Token implementation

use neo3::sdk::Neo;
use neo3::neo_types::{ScriptHash, ContractParameter};
use neo3::neo_error::unified::NeoError;
use std::sync::Arc;

pub struct Nep17Token {
    contract_hash: ScriptHash,
    neo_client: Arc<Neo>,
}

impl Nep17Token {
    pub fn new(contract_hash: ScriptHash, neo_client: Neo) -> Self {
        Self {
            contract_hash,
            neo_client: Arc::new(neo_client),
        }
    }
    
    /// Get token symbol
    pub async fn symbol(&self) -> Result<String, NeoError> {
        // Implementation would call the symbol method
        Ok("TOKEN".to_string())
    }
    
    /// Get token decimals
    pub async fn decimals(&self) -> Result<u8, NeoError> {
        // Implementation would call the decimals method
        Ok(8)
    }
    
    /// Get total supply
    pub async fn total_supply(&self) -> Result<u64, NeoError> {
        // Implementation would call the totalSupply method
        Ok(1_000_000_000)
    }
    
    /// Get balance of an address
    pub async fn balance_of(&self, address: &str) -> Result<u64, NeoError> {
        // Implementation would call the balanceOf method
        Ok(0)
    }
    
    /// Transfer tokens
    pub async fn transfer(
        &self,
        from: &str,
        to: &str,
        amount: u64,
        data: Option<String>,
    ) -> Result<String, NeoError> {
        // Implementation would build and send transfer transaction
        Ok("0x...".to_string())
    }
}
'''

"contracts/token.py" = '''
"""
NEP-17 Token Smart Contract
This is a Python implementation for Neo N3 using neo3-boa
"""

from typing import Any, Union
from boa3.builtin import NeoMetadata, metadata, public
from boa3.builtin.contract import Nep17TransferEvent, abort
from boa3.builtin.interop import runtime, storage
from boa3.builtin.interop.blockchain import get_contract
from boa3.builtin.interop.contract import call_contract
from boa3.builtin.type import UInt160

# Token metadata
OWNER = UInt160()  # Set owner address
SUPPLY_KEY = b'totalSupply'
SYMBOL = 'TOKEN'
DECIMALS = 8
INITIAL_SUPPLY = 1_000_000_000 * (10 ** DECIMALS)

# Events
on_transfer = Nep17TransferEvent

@metadata
def manifest() -> NeoMetadata:
    meta = NeoMetadata()
    meta.author = "Your Name"
    meta.email = "your.email@example.com"
    meta.description = "NEP-17 Token Contract"
    meta.supported_standards = ["NEP-17"]
    return meta

@public
def symbol() -> str:
    """Get token symbol"""
    return SYMBOL

@public
def decimals() -> int:
    """Get token decimals"""
    return DECIMALS

@public
def totalSupply() -> int:
    """Get total token supply"""
    return storage.get(SUPPLY_KEY).to_int()

@public
def balanceOf(account: UInt160) -> int:
    """Get balance of an account"""
    assert len(account) == 20
    return storage.get(account).to_int()

@public
def transfer(from_address: UInt160, to_address: UInt160, amount: int, data: Any) -> bool:
    """Transfer tokens from one address to another"""
    assert len(from_address) == 20 and len(to_address) == 20
    assert amount >= 0
    
    # Check if caller is authorized
    if from_address != runtime.calling_script_hash:
        if not runtime.check_witness(from_address):
            return False
    
    # Check balance
    from_balance = storage.get(from_address).to_int()
    if from_balance < amount:
        return False
    
    # Perform transfer
    if from_address != to_address and amount != 0:
        if from_balance == amount:
            storage.delete(from_address)
        else:
            storage.put(from_address, from_balance - amount)
        
        to_balance = storage.get(to_address).to_int()
        storage.put(to_address, to_balance + amount)
    
    # Fire transfer event
    on_transfer(from_address, to_address, amount)
    
    # Post-transfer contract call
    if to_address != runtime.calling_script_hash:
        contract = get_contract(to_address)
        if contract is not None:
            call_contract(to_address, 'onNEP17Payment', [from_address, amount, data])
    
    return True

@public
def _deploy(data: Any, update: bool):
    """Initialize contract on deployment"""
    if not update:
        storage.put(SUPPLY_KEY, INITIAL_SUPPLY)
        storage.put(OWNER, INITIAL_SUPPLY)
        on_transfer(None, OWNER, INITIAL_SUPPLY)
'''

"Cargo.toml" = '''
[package]
name = "{{project_name}}"
version = "0.1.0"
edition = "2021"

[dependencies]
neo3 = "0.5.0"
tokio = { version = "1.45", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
clap = { version = "4.0", features = ["derive"] }
hex = "0.4"
base64 = "0.21"

[dev-dependencies]
mockall = "0.13"
'''

"README.md" = '''
# {{project_name}} - NEP-17 Token

A NEP-17 compliant fungible token implementation using NeoRust SDK v0.5.2.

## Features

- âœ… NEP-17 standard compliance
- âœ… Token transfers
- âœ… Balance queries
- âœ… Total supply management
- âœ… Event emission

## Smart Contract

The `contracts/token.py` file contains the NEP-17 token smart contract written in Python for neo3-boa.

### Compiling the Contract

1. Install neo3-boa:
   ```bash
   pip install neo3-boa
   ```

2. Compile the contract:
   ```bash
   neo3-boa contracts/token.py
   ```

3. Deploy to TestNet:
   ```bash
   neo-cli contract deploy contracts/token.nef contracts/token.manifest.json
   ```

## Token Management

### Check Balance
```bash
cargo run -- balance <address>
```

### Transfer Tokens
```bash
cargo run -- transfer <from> <to> <amount>
```

### Get Token Info
```bash
cargo run -- info
```

## Configuration

Update the token contract hash in `src/main.rs` after deployment.

## Testing

```bash
cargo test
```

## License

MIT
'''
